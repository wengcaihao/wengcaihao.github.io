<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="水中岚的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="水中岚">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="水中岚">
<meta property="og:description" content="水中岚的博客">
<meta property="og:locale">
<meta property="article:author" content="水中岚">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>水中岚</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">水中岚</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">尽人事 听天命</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="水中岚"
      src="/uploads/me.jpg">
  <p class="site-author-name" itemprop="name">水中岚</p>
  <div class="site-description" itemprop="description">水中岚的博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/23/%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/23/%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/" class="post-title-link" itemprop="url">无线接口协议栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-23 11:03:49 / 修改时间：19:47:49" itemprop="dateCreated datePublished" datetime="2022-04-23T11:03:49+08:00">2022-04-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>1.在5G系统中，将终端和接入网之间的接口简称为<strong>Uu接口</strong>，也成为<strong>空中接口</strong>。</p>
<p>2.<strong>无线接口协议</strong>：建立、重配置和释放各种无线承载业务。主要分为三层两面，三层指的是<strong>物理层、数据链路层、网络层</strong>；两面指的是<strong>控制平面</strong>和<strong>用户平面</strong>。</p>
<ul>
<li><p>物理层是指MAC层，位于控制平面和用户平面。</p>
</li>
<li><p>数据链路层可分成媒体访问控制（MAC）层、无线链路控制（RLC）层、分组数据汇聚协议（PDCP）层、服务数据自适应协议（SDPA）四个子层，相比于LTE多了SDPA层，且SDPA层只位于用户平面，其余三个子层同时位于控制平面和用户平面。</p>
</li>
<li><p>网络层指无线资源控制（RRC）层，位于控制平面。</p>
</li>
</ul>
<p>3.无线接口协议栈</p>
<ul>
<li>控制平面协议栈：负责对无线接口的管理和控制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图1.png 控制平面协议栈 %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用户平面协议栈</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图2.png 用户平面协议栈 %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="物理层协议功能"><a href="#物理层协议功能" class="headerlink" title="物理层协议功能"></a>物理层协议功能</h2><p>物理层为MAC和更好层提供信息传输服务，其中所提供的服务通过传输信道来描述。</p>
<p>1.下行传输信道类型</p>
<ul>
<li>广播信道BCH：采用固定的预定义传输格式，能偶在整个小区覆盖区域内广播。</li>
<li>下行共享信道DL_SCH：使用混合自动重传请求（HARQ）传输，能够通过调整传输使用的调制方式、编码速率和发送功率来实现链路自适应，在整个小区内发送或使用波束赋形发送，支持动态或半静态的资源分配，支持终端非连续接收，达到节电的目的。</li>
<li>寻呼信道PCH：支持终端非连续接收，能在整个小区覆盖范围传输，使用映射到可用于动态使用的业务或者其他的控制信道的物理资源上。</li>
</ul>
<p>2.上行传输信道类型</p>
<ul>
<li>上行共享信道UL_SCH：与下行共享信道DL_SCH一样</li>
<li>随机接入信道RACH：承载有限的控制信息，并且具有冲突碰撞特征。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图3.png 映射关系 %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据链路层协议功能"><a href="#数据链路层协议功能" class="headerlink" title="数据链路层协议功能"></a>数据链路层协议功能</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图4.png 数据链路层的下行架构 %&#125;</span><br><span class="line">&#123;% asset_img 图5.png 数据链路层的上行架构 %&#125;</span><br></pre></td></tr></table></figure>

<p>物理层为MAC子层提供传输信道级的服务，MAC子层为RLC子层提供逻辑信道级的服务，RLC子层为PDCP子层提供RLC信道级服务，PDCP子层为SDAP子层提供无线承载级的服务，SDAP子层为上层提供SGC Qos流级的服务。</p>
<h3 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h3><p>Ⅰ、MAC子层的功能</p>
<p>①逻辑信道到传输信道的映射</p>
<p>②来自多个逻辑信道的MAC业务数据单元的复用和解复用</p>
<p>③上行调度信息上报</p>
<p>④通过HARQ进行错误纠正</p>
<p>⑤通过动态调度实现UE间的优先级处理</p>
<p>⑥通过逻辑信道优先级来实现终端内多个逻辑信道的优先级处理</p>
<p>⑦当实际传输数据量不能填满整个授权的数据库大小时使用填充功能</p>
<p>Ⅱ、逻辑信道</p>
<p>MAC层根据传输的信息类型划分为多种逻辑信道类型，针对不同的数据类型，提供不同的传输服务。一般将逻辑信道分为<strong>控制信道</strong>（传输控制平面信息）和<strong>业务信道</strong>（传输用户平面信息）</p>
<p>控制信道分为</p>
<ul>
<li>广播控制信道BCCH：为系统广播信息传输使用的下行信道。</li>
<li>寻呼控制信道PCCH：为传输寻呼信息、系统信息改变通知消息以及指示是否有正在广播的公共告警系统信息的下行信道。</li>
<li>公共控制信道CCCH：用于当终端和网络之间没有无线资源控制层（RRC）时，传输终端和网络之间的控制信息，双向。</li>
<li>专用控制信道DCCH：为点对点的双向信道，用于终端侧和网络侧存在RRC时的专用控制信息传输，双向。</li>
</ul>
<p>业务信道仅有专用业务信道DTCH，用于针对单个用户的点到点的业务传输信道，可单向可双向。</p>
<p>Ⅲ、逻辑信道与传输信道的映射关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图6.png 上行逻辑信道到上行传输信道的映射关系 %&#125;</span><br><span class="line">&#123;% asset_img 图7.png 下行逻辑信道到下行传输信道的映射关系 %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RLC子层"><a href="#RLC子层" class="headerlink" title="RLC子层"></a>RLC子层</h3><p>为了满足不同的业务需求，RLC子层支持三种传输模式：<strong>透明模式</strong>（TM）、<strong>非确认模式</strong>（UM）、<strong>确认模式</strong>（AM）。RLC的配置基于逻辑信道的颗粒度，不依赖于底层的参数集和传输时间间隔的长度。</p>
<p>透明模式主要用于寻呼消息、系统信息广播以及SRB0信令的传输</p>
<p>其他SRB信令用确认模式传输</p>
<p>用于传输用户数据的DRB可以根据业务类型选择确认模式或非确认模式。</p>
<p><strong>补充</strong>：RB&#x3D;Resource Bearer（终端与基站之间的承载） SRB&#x3D;Signal RB（终端与基站之间的信令承载） DRB &#x3D; Data RB（终端与基站之间的数据承载）</p>
<p>其中<strong>SRB0</strong>用于使用CCCH逻辑信道的RRC消息，<strong>SRB1</strong>用于RRC消息（可能包括后向装载的NAS消息）以及SRB2建立之前的NAS消息，均使用DCCH逻辑信道。<strong>SRB2</strong>用于NAS消息，全部使用DCCH逻辑信道。<strong>SRB3</strong>用于UE在EN-DC中时的特定RRC消息，均使用DCCH逻辑信道。</p>
<h3 id="PDCP子层"><a href="#PDCP子层" class="headerlink" title="PDCP子层"></a>PDCP子层</h3><p>PDCP子层为控制平面和用户平面提供不同的服务。</p>
<p>PDCP子层用于用户平面的功能包括</p>
<ul>
<li>支持头压缩解压缩功能，包含健壮性报头压缩协议算法。</li>
<li>提供序列号使得其可以支持确认模式下逻辑信道向高层进行重排序、按需递交，及对底层SDU数据的重复检测。</li>
<li>切换过程中，支持对确认模式逻辑信道的PDCP SDU重传</li>
<li>加密、解密和完整性保护</li>
<li>业务平面数据的传输</li>
<li>上行基于定时器的SDU丢弃机制</li>
<li>支持PDCP分离承载的路由功能</li>
<li>复制PDCP PDU，将其分发到不同路径上。</li>
</ul>
<p>PDCP子层用于控制平面的功能包括：</p>
<ul>
<li>加密、解密和完整性保护；</li>
<li>控制平面数据的传输；</li>
<li>提供序列号使得其可以支持确认模式下逻辑信道向高层进行重排序、按需递交，及对底层SDU数据的重复检测。</li>
<li>复制PDCP PDU，将其分发到不同路径上。</li>
</ul>
<p><strong>补充</strong>：SDU为服务数据单元，PDU为协议数据单元，本层的PDU是下层的SDU，本次的SDU是上层的PDU。</p>
<h3 id="SDAP子层"><a href="#SDAP子层" class="headerlink" title="SDAP子层"></a>SDAP子层</h3><p>SDAP子层主要功能是完成QoS流和DRB之间的映射，对上行和下行数据分组增加QoS流的标识号，并将不同的QoS流映射到数据无线承载上，每个独立的PDU会话会配置一个SDAP实体。</p>
<h2 id="RRC层协议功能"><a href="#RRC层协议功能" class="headerlink" title="RRC层协议功能"></a>RRC层协议功能</h2><p>RRC层协议模块是接入层的控制中心，其功能包括：发送系统信息广播（非接入层和接入层）相关信息、发送由核心网5GC和接入网NG-RAN发起的寻呼消息，UE和NG-RAN之间的RRC建立、维护和释放，安全功能密钥管理，无线承载管理（包括建立、配置、维护和释放信令无线承载和用户无线承载），移动性管理（包括切换、UE小区选择和重选、切换时上下文传输），QoS管理，UE测量报告和控制，无线链路失败的检测和恢复，以及NAS消息的传输。</p>
<p>RRC协议状态由LTE的3个增加为3个：RRC_IDEL、RRC_INACATIVE、RRC_CONNECTED</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/04/%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/" class="post-title-link" itemprop="url">第6章_接口、lambda表达式与内部类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-04 20:33:36" itemprop="dateCreated datePublished" datetime="2022-04-04T20:33:36+08:00">2022-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-05 14:11:29" itemprop="dateModified" datetime="2022-04-05T14:11:29+08:00">2022-04-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>1.接口中不能含有实例域，但是可以含有常量（接口中的域自动声明为public static final），可以含有方法，在Java SE 8之后，可以在接口中实现方法。此外，接口中的所有方法自动地属于public。但是，在实现接口的类中应该将方法显示声明为public。在Java SE 8中，允许在接口中增加静态方法。</p>
<p>2.接口与抽象类：每个类只能扩展一个类，而接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<p>3.默认方法：可以在接口中为接口方法提供一个默认实现，但必须用default标记该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样当某个类实现这个接口时，可以无需实现这个默认方法，并且该类调用该方法时，也会转成调用接口的这个方法，不会报错。</p>
<p>4.解决默认方法冲突：</p>
<p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，Java解决这种二义性的规则如下：</p>
<ol>
<li>超类优先：如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li>
<li>接口冲突：如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li>
</ol>
<h1 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/03/%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/03/%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">第5章_继承</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-03 15:12:54" itemprop="dateCreated datePublished" datetime="2022-04-03T15:12:54+08:00">2022-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-04 20:18:35" itemprop="dateModified" datetime="2022-04-04T20:18:35+08:00">2022-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h1><p>1.子类无法直接访问超类的私有域，虽然子类对象也拥有与超类同名的域。不过可以通过super.域访问器来访问超类的私有域。</p>
<p>2.子类构造器：由于子类无法直接访问超类的私有域，所以子类的初始化必须利用超类的构造器对私有域进行初始化。使用super调用构造器的语句必须是子类构造器的第一句，如果子类构造器没有显式调用超类构造器，将自动调用超类无参构造器。如果子类没有显式调用超类构造器并且超类也没有无参构造器，则Java编译器会报错。</p>
<p>3.关键字this有两个用途：一是引用隐式参数，二是调用该类的其他的构造器。</p>
<p>而关键字super有两个用途：一是调用超类的方法，二是调用超类的构造器。</p>
<p>4.多态：一个对象变量可以指示多种实际类型的现象被称为多态。</p>
<p>一个Employee变量既可以引用一个Employee类对象，也可以引用Employee类的任何一个子类的对象。然而，不能将一个超类的引用赋值给子类变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Manager</span>(...);<span class="comment">//Manager extends Employee</span></span><br></pre></td></tr></table></figure>

<p>在Java中，子类数组的引用可以转换为超类数组的引用，而不需要强制转换。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager[] managers = <span class="keyword">new</span> <span class="title class_">Manager</span>[<span class="number">10</span>];</span><br><span class="line">Employee[] staff = manager;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<p>此时manager和staff引用的是同一个数组，虽然上述代码没有问题，但当往staff中存入一个Employee对象时，manager[0]和staff[0]引用的是同一个Employee对象，似乎我们把一个Employee对象引用赋值给一个Manager。为了不犯这种错误时，所有数组都要牢记创建它们的元素类型，并且负责监督仅将类型兼容的引用存储到数组中。</p>
<p>5.在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p>
<p>6.动态绑定：运行时能够自动地选择调用哪个方法的现象称为动态绑定。</p>
<p>7.阻止继承：final类和方法。</p>
<p>如果一个类被声明为final，则这个类不能被继承。类中的方法也被声明为final，而域并不会被声明为final。</p>
<p>如果一个方法被声明为final，则这个方法不能被重写。</p>
<p>如果一个域被声明为final，则这个方法不能被再次赋值。</p>
<p>8.强制类型转换（尽量少使用）</p>
<ul>
<li>只能在继承层次内进行类型转换。</li>
<li>在将超类转换成子类之前，应该使用instanceof进行检查。</li>
</ul>
<p>9.抽象类</p>
<p>抽象方法充当着占位的角色，它们的具体实现在子类中。包含一个或多个抽象的方法的类需要声明为抽象类，反之，抽象类可以不拥有抽象方法。扩展抽象类可以有两种选择。一种是在抽象类定义部分抽象类方法或不定义抽象方法，这样子类就必须标记为抽象类。另一种是定义全部的抽象方法，这样子类就无需定义为抽象类。</p>
<p>10.Java的4个访问修饰符</p>
<ol>
<li>仅对本类可见—-private。</li>
<li>对所有类可见—-public。</li>
<li>对本包和所有子类可见—-protected。</li>
<li>对本包可见—-默认，不需要修饰符。</li>
</ol>
<h1 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h1><p>1.equals方法：在Object类中，这个方法将判断两个对象是否具有相同的引用。然而对于许多类来说这种方法没有意义，因此会重写equals类用来比较内容。例如：如果两个雇员对象的姓名、薪水和雇佣日期都一样，就认为它们是相等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == otherObject)<span class="comment">//判断是否为同一对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (otherObject == <span class="literal">null</span>)<span class="comment">//判断是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass())<span class="comment">//判断类型是否相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//至此，otherObject可证得是引用的非空的Employee对象</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;<span class="comment">//强制转换</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, other.name)</span><br><span class="line">                &amp;&amp; salary == other.salary</span><br><span class="line">                &amp;&amp; Objects.equals(hireDay, other.hireDay);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面给出编写一个完美的equals方法的建议：</p>
<ol>
<li><p>显示参数命名为otherObject，稍后需要将它转换为另一个叫做other的变量。</p>
</li>
<li><p>检测this与otherObject是否引用同一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测otherObject是否为null，如是则返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变（如Employee比较姓名、薪水、雇佣日期，而Manager比较姓名、薪水、雇佣日期和奖金，因此二者equals语义不同），就是用getClass检测。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>如果所有子类都拥有统一的子类，就是用instanceof检测</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将otherObject转换为相应的类类型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对所有需要的域进行比较。使用&#x3D;&#x3D;比较基本类型域，使用equals比较对象域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">return</span> <span class="variable">field1</span> <span class="operator">=</span>= other.field1</span><br><span class="line">                &amp;&amp; Objects.equals(field2, field2);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.hashCode方法：重写equals方法就必须重写hashCode方法。因为hashCode和equals两个方法是用来协同判断两个对象是否相等，采用这种方式的原因是可以提高程序插入和查询的速度。如果重写equals时，不重写hashCode，就会导致在某些场景下，如将两个相等的自定义对象存储在Set集合时，Set进行去重操作，会先判断两个对象hashCode是否相同，返回false，就不再执行equals方法，直接返回false。则在Set中保留了两个一摸一样的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Equals和hashCode的定义必须一致，如果x.equals(y)返回true，那么x.hashCode和y.hashCode返回值就必须一致。如：equals比较雇员的ID，那么hashCode方法就需要散列ID。</p>
<p>3.toString方法：强烈建议为自定义的每一个类增加toString方法。</p>
<h1 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h1><p>1.基本数据类型的包装器类：Integer、Long、Float、Double、Short、Byte、Character和Boolean，前六个类全派生于超类Number。</p>
<p>自动装箱：将基本数据类型自动转换为对应的包装器类。</p>
<p>自动拆箱：将包装器类自动转换为对应的基本数据类型。</p>
<p>对象包装器类是不可变的，一旦构造了包装器，就不可更改包装在其中的值。此外，对象包装器类是final，因此不能定义它们的子类。</p>
<h1 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> format(fmt, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数为Object[]数组，如果调用者提供的是整型数组和其他基本类型的值，则会自动装箱。</p>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>1.在比较两个枚举类型的值时，永远不要调用equals，而直接使用“&#x3D;&#x3D;”就可以了。</p>
<p>2.枚举类中可以添加域、方法、构造器，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String abbreciation;</span><br><span class="line"></span><br><span class="line">    Size(String abbreciation) &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbreciation = abbreciation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreciation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbreciation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h1><ol>
<li>将公共操作和域放在超类。</li>
<li>不要使用受保护的域。</li>
<li>使用继承实现“is-a”关系。</li>
<li>除非所有继承的方法都有意义，否则不要使用继承。</li>
<li>在覆盖方法时，不要改变预期的行为。</li>
<li>使用多态，而非类型信息。</li>
<li>不要过多的使用反射。</li>
</ol>
<p>本章就到这了~</p>
<img src="/2022/04/03/%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/%E9%B8%A3%E4%BA%BA.webp" class title="鸣人">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/01/%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/01/%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/" class="post-title-link" itemprop="url">第4章_对象与类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-01 20:46:58" itemprop="dateCreated datePublished" datetime="2022-04-01T20:46:58+08:00">2022-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-03 10:46:56" itemprop="dateModified" datetime="2022-04-03T10:46:56+08:00">2022-04-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h1><p>1.类是构造对象的模板和蓝图。</p>
<p>封装：封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域，而仅通过对象的方法与对象数据进行交互。这样对对象的使用者就隐藏了数据的实现方法。OOP的另一原则为继承。</p>
<p>2.对象的三个主要特征</p>
<ul>
<li>对象的行为：可以对对象施加哪些方法？</li>
<li>对象的状态：当实践那些方法时，对象如何响应？</li>
<li>对象标识：如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>3.类之间的关系</p>
<ul>
<li>依赖（”uses-a“）：如果一个类A的方法操纵另一个类B的对象，则说类A依赖于类B。代码应尽量将相互依赖的类减至最少，以减小产生代码的概率，即让类之间的耦合度最小。</li>
<li>聚合（”has-a“）：即类A的对象包含B的对象。</li>
<li>继承（”is-a“）：表示特殊与一般的关系，下一章会详细讨论。</li>
</ul>
<h1 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h1><p>1.Date类与LocalDate类</p>
<p>标准Java类库包含了两个类：一个是用来表示时间点的Date类；另一个是用来表示日历的LocalDate类。</p>
<p>以上两种类的构造对象方法不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">deadline</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//Date类使用构造器来构造方法</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();<span class="comment">//LocalDate使用静态工厂方法</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">newYearsEve</span> <span class="operator">=</span> LocalDate.of(<span class="number">1999</span>,<span class="number">12</span>,<span class="number">31</span>);</span><br></pre></td></tr></table></figure>

<p>一个用来显示本月日历的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> date.getMonthValue();<span class="comment">//目前的月份</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> date.getDayOfMonth();<span class="comment">//目前的日期</span></span><br><span class="line"></span><br><span class="line">        date = date.minusDays(today - <span class="number">1</span>);<span class="comment">//将date转为本月的第一天</span></span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> date.getDayOfWeek();<span class="comment">//本月第一天的星期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue();<span class="comment">//1-&gt;星期一 2-&gt;星期二  以此类推</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; value; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (date.getMonthValue() == month) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>, date.getDayOfMonth());</span><br><span class="line">            <span class="keyword">if</span> (date.getDayOfMonth() == today) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            date = date.plusDays(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (date.getDayOfWeek().getValue() == <span class="number">1</span>)</span><br><span class="line">                System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (date.getDayOfWeek().getValue() != <span class="number">1</span>)</span><br><span class="line">            System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h1><p>1.隐式参数与显示参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(<span class="type">double</span> byPercent)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary += raise;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出现在方法面前的类对象称为隐式参数，在每一个方法中，用关键字this表示隐式参数。而位于方法名后括号中的数值称为显示参数，如double byPercent。</p>
<p>2.final实例域</p>
<p>当将实例域定义为final，构建对象时必须初始化这样的域，并且在后面的操作中，不能够再对他进行修改。因此，final修饰符大多应用于基本类型域或不可变类的域。</p>
<h1 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h1><p>1.静态域：如果将域定义为static，则该类的所有对象共享这个域，这个域属于这个类而非某个对象。</p>
<p>2.静态常量：静态变量使用较少，而静态常量却使用较多。静态常量可以直接通过类来访问，而无需通过类的对象再来访问，如Math类中定义了一个静态常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure>

<p>在程序中即可通过Math.PI的形式得到这个值。</p>
<p>这行代码中PI虽然为公有域，可以被每个类对象进行修改，但是又由于其被final修饰，不允许再次赋值，所以不会面临被修改的风险。</p>
<p>3.静态方法：静态方法是一种不能向对象实时操作的方法，即没有隐式参数。静态方法无法访问类中非静态方法与非静态域，但是可以访问自身类中的静态域。</p>
<p>以下两种情况使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，所需参数都是显示参数，如Math.pow。</li>
<li>一个方法只需要访问类中的静态域。</li>
</ul>
<h1 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h1><p>1.计算机科学中有两种调用方式：</p>
<ul>
<li>按值调用：方法接收的是调用者提供的值。</li>
<li>按引用调用：方法接收的是调用者提供的变量地址。</li>
</ul>
<p><strong>Java总是采用按值调用。</strong>而Java方法参数的使用情况可以分为以下三种：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tripleValue</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">        x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使通过上述方法将变量value赋值给参数x，也无法修改value的值。因为value只将它的值赋给了x，参数变量x在方法结束就不再使用，无法对value造成影响。</p>
<ul>
<li>一个方法可以改变一个对象参数的状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tripleSalary</span><span class="params">(Employee x)</span> &#123;</span><br><span class="line">        x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法可以成功修改Employee对象的状态（即Salary提高两倍），因为参数变量被赋予的是一个对象引用。</p>
<ul>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Employee x, Employee y)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上方法无法成功让两个对象参数互换。假设我们通过以下代码调用上面这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Carl Cracker&quot;</span>, <span class="number">75000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry Hacker&quot;</span>, <span class="number">50000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">swap(a, b);</span><br></pre></td></tr></table></figure>

<p>首先，我们需要明白a，b的值分别对应的都是一个Employee对象的引用。因此，当调用swap方法时参数变量x，y的值也是Employee对象的引用。经过swap方法后，参数变量x，y值对换，即双方引用的对象交换了。但是a，b的值并没有变化。</p>
<h1 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h1><p>2.无参数的构造器</p>
<p>当类没有提供任何构造器时，系统会提供一个默认的无参构造器。但是当类给出了一个构造器，此时系统不会默认提供无参构造器，如果需要则需要显式声明。</p>
<p>3.调用另一个构造器</p>
<p>构造器的第一个语句可以为形如this(…)的形式，这样这个构造器可以调用本类的其他构造器，从而避免重复编写代码。</p>
<p>4.初始化块：初始化块是除了在构造器中赋值、在声明中赋值外的第三种初始化数据域方式。初始化数据域有多种方式，以下为调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值（0、false、null）</li>
<li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器的第一行调用了第二个构造器，则执行第二个构造器的主体。</li>
<li>执行第一个构造器的主体。</li>
</ol>
<h1 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h1><ol>
<li><p>一定要保证数据私有：绝对不要破坏封装性。</p>
</li>
<li><p>一定要对数据初始化：不要依赖于系统的默认值，而是应该显式地初始化所有的数据，具体的初始化方式可以是提供默认值，也可以在所有构造器中设置默认值。</p>
</li>
<li><p>不要在类中使用过多的基本类型：用其他的类代替多个相关的基本类型的使用。例如：用一个称为Address的新类替换一个Customer类中以下的实例域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String street;</span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> zip;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不是所有的域都需要独立的域访问器和域更改器。</p>
</li>
<li><p>将职责过多的类进行分解。</p>
</li>
<li><p>类名和方法名要能够体现它们的职责。</p>
</li>
<li><p>优先使用不可变的类：这样可以在多个线程间共享其对象。当然，并不是所有的类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这回很奇怪。</p>
</li>
</ol>
<p>好了，本章就到这了~~</p>
<img src="/2022/04/01/%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/1.webp" class title="这是一直杰尼龟">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Hexo搭建博客图片无法显示问题解决方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-01 19:32:49 / 修改时间：20:24:28" itemprop="dateCreated datePublished" datetime="2022-04-01T19:32:49+08:00">2022-04-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>基于Hexo搭建的博客平台在上传图片时会遇到图片无法打开的情况，解决方法如下：</p>
<p>1.在博客的根目录下的配置文件_config.yml中的post_asset_folder: false改为true（注意:后有一空格），这样在新建博客时就会自动建立一个同名的文件夹，这样我们可以将博客中用到的图片放在上述文件夹中。</p>
<img src="/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E6%AD%A5%E9%AA%A41.png" class title="步骤1">

<p>2.git bash安装插件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>如果git bash安装插件失败，可以试试以管理员方式运行cmd，然后转到博客所在的文件夹，在执行上述命令。</p>
<p>3.在编写博客时，需要用到图片的地方使用以下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 杰尼龟.webp 这是一直杰尼龟 %&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的 杰尼龟.webp 改成第一步中自动建立的文件夹中所需图片的名字 + .图片格式（jpg，png等），将上面的 这是一只杰尼龟 改成你图片的描述。</p>
<p>这样问题就解决了，效果如下：</p>
<img src="/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E6%9D%B0%E5%B0%BC%E9%BE%9F.webp" class title="这是一直杰尼龟">


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/30/%E7%AC%AC3%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/30/%E7%AC%AC3%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">第3章_Java的基本程序设计结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-30 20:45:16" itemprop="dateCreated datePublished" datetime="2022-03-30T20:45:16+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-01 19:29:13" itemprop="dateModified" datetime="2022-04-01T19:29:13+08:00">2022-04-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一个简单的Java应用程序"><a href="#一个简单的Java应用程序" class="headerlink" title="一个简单的Java应用程序"></a>一个简单的Java应用程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;We will not use &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>public称为<strong>访问修饰符</strong>，用于控制程序的其他部分对于该代码的访问级别，访问修饰符将在第5章详细介绍。</p>
<p>class为关键字，可将class（类）看作一个加载程序逻辑的容器。</p>
<p>class后紧跟类名FirstSample，Java定义类名的规则为：名字必须以字母开头，后面可跟字母和数字的任意组合，长度基本没有限制，但是不能使用Java的保留字（如public、class等）作为类名。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Java中，有3种标记注释的方法，分别为：</p>
<p>1.使用&#x2F;&#x2F;，注释内容从&#x2F;&#x2F;开始到本行结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;We will not use &#x27;Hello World!&#x27;&quot;</span>);<span class="comment">//is this too cute?</span></span><br></pre></td></tr></table></figure>

<p>2.使用&#x2F;* 和*&#x2F;将长篇的注释括起来，注意，在Java中&#x2F;**&#x2F;不能嵌套。</p>
<p>3.以&#x2F;**开始，以 *&#x2F;结束，可以用来自动生成文档。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 水中岚</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java是一种强类型语言，意味着必须为每一个变量声明一种类型。在Java中一共有8种基本类型，包含4种整形，2种浮点类型，一种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真假的boolean类型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储要求</th>
<th align="center">类型</th>
<th align="center">储存要求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">float</td>
<td align="center">4字节</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">double</td>
<td align="center">8字节</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">char</td>
<td align="center">2字节</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">1字节</td>
<td align="center">boolean</td>
<td align="center">1字节</td>
</tr>
</tbody></table>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>1.常量：在Java中，利用关键字final指示常量，其表示这个变量只能被赋值一次，习惯上，常量名使用全大写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">CM_PER_INCH</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br></pre></td></tr></table></figure>

<p>2.数值类型之间的转换</p>
<img src="/2022/03/30/%E7%AC%AC3%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" class title="数字类型之间的转换">

<p>上图给出了Java中的合法转换，其中实线表示转换时无精度损失，虚线表示转换时有精度损失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123456789</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> n;<span class="comment">//f is 1.23456792E8</span></span><br></pre></td></tr></table></figure>

<p>如果需要非合法转换时，如需要将double转为int，则需要用到强制类型转换。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>1.equals用来比较字符串是否相等，&#x3D;&#x3D;用来比较两个字符串位置是否相同。虽然位置相同的字符串值必定相等，但相等的字符串并不一定会在同一位置。</p>
<p>2.文件输入与输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.get(<span class="string">&quot;myfile.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//读取文件</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//写入数据至文件</span></span><br></pre></td></tr></table></figure>

<p>注意，读取文件不能使用下面的形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>否则，scanner变量 in 会将参数作为包含了’m’、’y’、’f’、’i’等十个字符的数据，而非参数字符串对应的文件中的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/25/hexo%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/25/hexo%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Hexo编写博客</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-25 10:35:47 / 修改时间：15:39:52" itemprop="dateCreated datePublished" datetime="2022-03-25T10:35:47+08:00">2022-03-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文将针对”Hexo编写博客“进行记录</p>
<h1 id="Hexo写作"><a href="#Hexo写作" class="headerlink" title="Hexo写作"></a><strong>Hexo写作</strong></h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>创建文章、页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;文章名&gt;</span><br></pre></td></tr></table></figure>

<p>在你的博客文件下打开Git Bash，输入上方命令，[layout]表示布局，为可选参数。&lt;文章名&gt;为你想要创建的文章名字，输入时删去&lt;&gt;符号，保留文章名即可。</p>
<p>Hexo有三种默认的布局，分别为post、page、draft，不同的文件将会被保存在不同的路径。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>文件保存路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source&#x2F;_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source&#x2F;_drafts</td>
</tr>
</tbody></table>
<p>Hexo默认以文章名为文件名称，当然，我们也可以修改_config.yml配置文件中的new_post_name参数来修改默认文件名称。如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>

<p>则可以在文件名中添加上日期，方便管理。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:title</td>
<td>标题（空格将会替换为短杆）</td>
</tr>
<tr>
<td>:year</td>
<td>建立文件的年份</td>
</tr>
<tr>
<td>:month</td>
<td>建立文件的月份，如04</td>
</tr>
<tr>
<td>:i_month</td>
<td>建立文件的月份，如4</td>
</tr>
<tr>
<td>:day</td>
<td>建立文件的日期，如03</td>
</tr>
<tr>
<td>:i_day</td>
<td>建立文件的日期，如3</td>
</tr>
</tbody></table>
<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter指的是文件上方以 — 分割的区域，用于设置文件的参数。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo编写博客</span><br><span class="line">date: 2022-03-25 10:35:47</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>下表为一些可以设置的参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td>post</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>文章的文件名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文章的建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
<td></td>
</tr>
</tbody></table>
<h2 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h2><p>Hexo官网（<a href="Hexo%E5%AE%98%E7%BD%91"> https://hexo.io/zh-cn/docs/tag-plugins</a>）中提供一些文章中快速插入如引用块、代码等特定内容的插件。这里，我推荐直接使用Typora来完成文章的编写。</p>
<p>Typora是一款Markdown编辑器，当我们输入完标记语言后就可以直接看见效果，并且许多标记语言可以直接通过快捷键或者软件上方工具栏来设置。</p>
<h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>最后，在编写完文章后，不要忘记重新部署</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">水中岚</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
