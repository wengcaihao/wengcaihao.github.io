<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="水中岚的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="水中岚">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="水中岚">
<meta property="og:description" content="水中岚的博客">
<meta property="og:locale">
<meta property="article:author" content="水中岚">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>水中岚</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">水中岚</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">尽人事 听天命</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="水中岚"
      src="/uploads/me.jpg">
  <p class="site-author-name" itemprop="name">水中岚</p>
  <div class="site-description" itemprop="description">水中岚的博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/" class="post-title-link" itemprop="url">第5章-系统初始接入与移动性管理设计-NR同步块（SSB）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-26 15:31:17" itemprop="dateCreated datePublished" datetime="2022-04-26T15:31:17+08:00">2022-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-27 10:47:33" itemprop="dateModified" datetime="2022-04-27T10:47:33+08:00">2022-04-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>UE和网络进行数据传输之前，必须通过初始接入过程连接到网络。初始接入过程包括小区搜索、系统信息接收和随机接入等阶段。</p>
<p>小区搜索是UE利用小区同步信号进行下行时间和频率同步，以及获得物理小区标识（PCID）的过程。</p>
<p>通过小区搜索完成下行同步之后，UE接收并解码物理广播和承载最小系统信息的PDSCH，获取后续进行随机接入必需的系统信息。</p>
<p>在获取系统信息之后，UE通过随机接入过程实现上行时间同步，从非RRC连接态（RRC_IDLE和RRC_INACTIVE）进入RRC连接态（RRC_CONNECTED），为上、下行数据传输做好准备。</p>
<p>寻呼过程用于帮助网络寻呼正处于非RRC连接态的UE。</p>
<p>移动性管理对有效利用系统资源，保证网络对UE提供合理服务至关重要。</p>
<p>5G NR移动管理包括无线资源管理（RRM）和无线链路监视（RLM）。</p>
<h1 id="NR同步块（SSB）"><a href="#NR同步块（SSB）" class="headerlink" title="NR同步块（SSB）"></a>NR同步块（SSB）</h1><p>NR同步块（SSB）包括主同步信号（PSS）、辅同步信号（SSS）和物理广播信道（PBCH）。PBCH中包含解调参考信号（DM-RS）。</p>
<p>UE在进入NR系统时，首先要检测主同步信号和辅同步信号以获得下行时频同步以及物理小区标识，然后对PBCH进行解码。PBCH中包括主信息块（MIB）和其他与NR同步块传输时间有关的信息。主信息块中携带了UE接入NR系统所需的最小系统信息的一部分。</p>
<h2 id="SSB的结构和SSB突发集"><a href="#SSB的结构和SSB突发集" class="headerlink" title="SSB的结构和SSB突发集"></a>SSB的结构和SSB突发集</h2><p>1.SSB的结构</p>
<img src="/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/%E5%9B%BE1.png" class title="SSB的结构">

<p>SSB中PSS、SSS、PBCH采用TDM的方式，一个SSB占用4个OFDM符号,一个SSB的带宽为20个PRB。每个SSB中PSS、SSS和PBCH采用相同的子载波间隔。</p>
<p>2.SSB搜索</p>
<p>初始接入时，UE不知道载波的具体带宽、频段内的载波带宽组合以及SSB在载波带宽中的位置。因此为了实现下行同步，UE按照<strong>同步栅格</strong>进行SSB搜索。SSB带宽的设计直接影响系统载波带宽中同步栅格的个数（正相关）。在一个系统载波带宽中，同步栅格的个数越多，UE搜索SSB所花费的时间就越多，而一个SSB内PSS、SSS和PBCH采用TDM相比于FDM可以减小SSB的带宽，从而减少同步栅格个数，降低搜索复杂度。</p>
<p>3.<strong>SSB突发集</strong></p>
<p>完成一次波束扫描所需的NR同步块组成了SSB突发集，SSB突发集是周期性传输的。配置较短的SSB突发集可以减少初始接入的时间延迟，降低UE测量SSB的时间和功耗，但会消耗较多的系统资源。反之，配置较长的SSB突发集周期可以减少SSB占用的资源，但可能会延长UE初始接入的时间。</p>
<h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><p>当检测到某个SSB时，UE将从SSB获取定时信息，以达到下行时间同步的目的。定时信息包括：系统帧号、半无线帧索引、半无线帧中的时隙索引和时隙中OFDM符号索引。</p>
<p>首先根据系统帧号以及半无线帧索引获取半无线帧中的位置。然后根据SSB时间索引，UE可结合NR标准规定的SSB在半无线帧中的位置，推断出该检测到的SSB在半无线帧中的时隙索引以及在该时隙中的OFDM符号索引。</p>
<h2 id="SSB在半无线帧中的位置"><a href="#SSB在半无线帧中的位置" class="headerlink" title="SSB在半无线帧中的位置"></a>SSB在半无线帧中的位置</h2><p>不同频率范围内一个SSB突发集的最大SSB个数不同，表示SSB时间索引所需的比特数不同。为了使UE根据检测到的SSB时间索引确定SSB在半无线帧中的位置，NR标准规定了各种场景中SSB的侯选位置在SSB半无线帧中相对半无线帧起始点的OFDM符号索引值，如表：</p>
<img src="/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/%E5%9B%BE2.png" class>

<p>例1：NR SSB 模式A为例，检测到SSB时间索引值为2，即SSB半无线帧中的第3个SSB，根据下图：</p>
<img src="/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/%E5%9B%BE3.png" class>

<p>结合表5-1，可知模式A下每个时隙有两个SSB，它们的起始OFDM符号分别为2和8，第3个SSB位于SSB半无线帧中的第2个时隙（$n&#x3D;1$）。所以相对半无线帧起始点的OFDM符号的索引值为14×1+2&#x3D;16</p>
<p>例2：NR SSB 模式D为例，检测到SSB时间索引值为7，即SSB半无线帧中的第8个SSB，根据下图：</p>
<img src="/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/%E5%9B%BE4.png" class>

<p>结合表5-1，可知模式D下每2个有4个SSB，第8个SSB位于SSB半无线帧中的第4个时隙（$n&#x3D;1$）,所以相对半无线帧起始点的OFDM符号的索引值为28×1+20&#x3D;48</p>
<h2 id="SSB传输配置"><a href="#SSB传输配置" class="headerlink" title="SSB传输配置"></a>SSB传输配置</h2><p>在初始小区搜索时，UE没有任何关于SSB传输配置的信息，为了减少UE初始小区搜索的时间和功耗，NR在协议中定义了一些SSB传输配置参数的默认值，包括SSB子载波间隔、SSB模式和SSB发送周期。</p>
<ul>
<li>NR在协议中按频段规定了默认的SSB子载波间隔。对于大多数频段来说，协议规定了唯一的默认SSB子载波间隔，也规定了唯一的默认SSB模式。但是对于某些特殊的频段，协议规定了两个默认子载波间隔，目的是希望保持这些特殊频段部署的灵活度，且对于这两个默认子载波间隔，协议针对每个子载波间隔都定义了唯一的默认SSB模式。</li>
<li>对于支持初始小区搜索的小区，SSB实际发送周期可以是5ms，10ms和20ms。对于不支持初始小区搜索的小区，其SSB发送周期可以为{5，10，20，40，80，160}ms。对于网络没有指示SSB发送周期的小区，UE应假设SSB的实际发送周期为5ms。</li>
</ul>
<h2 id="实际传输SSB的指示"><a href="#实际传输SSB的指示" class="headerlink" title="实际传输SSB的指示"></a>实际传输SSB的指示</h2><p>NR协议规定了每个频率范围内一个SSB突发集的最大SSB个数，实际传输中一个SSB突发集的SSB个数可以小于或等于协议规定的最大数。未传输的SSB资源可以用来PDSCH传输。NR通过高层参数ssb-PositionsInBurst通知UE实际传输的SSB的位置和个数，使UE在接收PDSCH时能正确地进行速率匹配。</p>
<p>NR规定了ssb-PositionsInBurst的两种表达方式：</p>
<ul>
<li><p>两个8比特位图，即组内比特映射（inOneGroup）和组比特映射（groupPresence）。</p>
<p>当频率小于6GHz时，SSB突发集最大SSB个数不超过8。inOneGroup的每个比特代表相应的SSB的位置是否实际用于传输SSB。而groupPresence没有实际意义。</p>
<p>当频率大于6GHz时，SSB突发集的最大SSB为64，NR将64个候选SSB按位置次序分为8组，groupPresence的每个比特表示相应的SSB组是否用于传输SSB，inOneGroup的每个比特表示每组中相应的SSB的位置是否实际用于传输SSB（配置不灵活）。</p>
</li>
<li><p>第二种方式采用3种长度分别为4位、8位和64位比特的位图，各比特代表相应的SSB的位置是否实际用于传输SSB。</p>
</li>
</ul>
<p>两种ssb-PositionsInBurst表达方式的设计初衷，前者采用16bit就可表达实际传输SSB的位置，但网络实际传输SSB的灵活性受到了限制。后者保留网络实际传输SSB配置的灵活性，但最多却需要64bit。</p>
<h2 id="同步信号设计"><a href="#同步信号设计" class="headerlink" title="同步信号设计"></a>同步信号设计</h2><p>同步信号包括主同步信号和辅同步信号。</p>
<p>NR设计了3个主同步信号序列，主同步信号序列的ID为$N_{ID}^{(2)}\in{0,1,2}$。每个主同步信号序列对应于336个辅同步序列，辅同步信号序列的ID为$N_{ID}^{(1)}\in{0,1,…,335}$。每个NR物理小区标识$N_{ID}^{cell}$由主同步信号序列ID和辅同步信号序列ID的组合共同确定，即$N_{ID}^{cell}&#x3D;3N_{ID}^{(1)}+N_{ID}^{(2)}$。所以NR共支持336×3&#x3D;1008个物理小区标识。</p>
<p>1.主同步信号</p>
<img src="/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/%E5%9B%BE5.png" class>

<p>2.辅同步信号</p>
<img src="/2022/04/26/%E7%AC%AC5%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E7%A7%BB%E5%8A%A8%E6%80%A7%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1-NR%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%88SSB%EF%BC%89/%E5%9B%BE6.png" class>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/24/CP-OFDM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/24/CP-OFDM/" class="post-title-link" itemprop="url">CP-OFDM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-24 14:18:24 / 修改时间：15:58:55" itemprop="dateCreated datePublished" datetime="2022-04-24T14:18:24+08:00">2022-04-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>OFDM：正交频分复用技术，是多载波调制的一种。OFDM的主要思想是：将信道分成若干个正交子信道，将高速数据信号转换成并行的低速子数据流，调制到每个子信道上进行传输。OFDM的调制和解调是基于IFFT和FFT实现的。</p>
<p>理想情况下，发送端所发送的符号到达接收端时不会受到任何影响。如图所示：</p>
<img src="/2022/04/24/CP-OFDM/%E5%9B%BE1.png" class title="理想情况">

<p>然而，现实情况中，由于多径、反射等情况，接收端可以接收到发送信号的多个延迟信号。如图所示</p>
<img src="/2022/04/24/CP-OFDM/%E5%9B%BE2.png" class title="现实情况">

<p>接收端接收到经过多个不同路径到达终点的信号，因此在图中所示的FFT window中t1采样点有来自Symbol1的干扰，这就是符号间干扰（ISI）。</p>
<p>我们称信号的第一个副本和该信号最后接收的一个副本之间的总延迟称为延迟扩展。如果符号周期与“延迟扩展”相比非常大，那么ISI带来的影响较小，反之，若符号周期与”延迟扩展“相比非常小，那么ISI带来的影响将非常大。</p>
<p>为了解决ISI，其中一个方法就是添加保护间隔，如图所示</p>
<img src="/2022/04/24/CP-OFDM/%E5%9B%BE3.png" class title="设置保护间隔">

<p>可以发现，在设置保护间隔后（保护间隔应该大于“延迟扩展”），在FFT Window中已经没有了其他信号的干扰了，然而由于保护间隔采用补零的措施，在接收端进行FFT时不同子载波之间已经不在正交，所以解调中的子载波会受到其他子载波的影响，这就是信道干扰（ICI），想要消除ICI，可以采用循环前缀（CP）或循环后缀（CS），这样既可以同时解决ISI和ICI。</p>
<img src="/2022/04/24/CP-OFDM/%E5%9B%BE4.png" class title="循环前缀">

<p>如图所示，将符号后部复制到符号前面作为保护间隔，这样FFT后不同子载波之间的内积为0，不同子载波相互正交，则不再有ISI和ICI。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/24/%E7%AC%AC4%E7%AB%A0-%E5%B8%A7%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E4%BF%A1%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/24/%E7%AC%AC4%E7%AB%A0-%E5%B8%A7%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E4%BF%A1%E9%81%93/" class="post-title-link" itemprop="url">第4章-帧结构与物理信道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-24 09:58:55" itemprop="dateCreated datePublished" datetime="2022-04-24T09:58:55+08:00">2022-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-26 15:15:59" itemprop="dateModified" datetime="2022-04-26T15:15:59+08:00">2022-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="波形和参数集设计"><a href="#波形和参数集设计" class="headerlink" title="波形和参数集设计"></a>波形和参数集设计</h1><p>5G下行的调制波形为CP-OFDM，上行的调制波形除了CP-OFDM外还有DFT-sOFDM。其中，CP-OFDM调制的关键参数包括子载波间隔和CP长度。LTE支持15kHz的子载波间隔，而NR支持多种子载波间隔，不同子载波之间呈倍数关系，并且倍数必须为2的整数次幂。</p>
<p>如果记$f_0&#x3D;15kHz$$,则NR支持的子载波间隔满足关系$$f_u&#x3D;2^uf_0,u&#x3D;0,1,2,3,4$</p>
<h1 id="时频资源"><a href="#时频资源" class="headerlink" title="时频资源"></a>时频资源</h1><h2 id="时域资源的定义"><a href="#时域资源的定义" class="headerlink" title="时域资源的定义"></a>时域资源的定义</h2><p>1.NR无线帧</p>
<p>NR<strong>无线帧</strong>长度定义为10ms，一个无线帧包含10个<strong>子帧</strong>，每个子帧长度为1ms。一个子帧进一步分为若干个<strong>时隙</strong>，具体的个数取决于子载波间隔，但无论子载波间隔多大，一个时隙都包括14个OFDM符号。如果子载波间隔为$f_u&#x3D;2^uf_0$，则一个子帧内包含$2^u$$个，每个时隙的长度为$$2^{-u}ms$。</p>
<p>NR帧结构如下：</p>
<img src="/2022/04/24/%E7%AC%AC4%E7%AB%A0-%E5%B8%A7%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E4%BF%A1%E9%81%93/%E5%9B%BE1.png" class title="NR帧结构">

<p>2.OFDM符号：一个时隙内的OFDM符号包括3种：下行符号、上行符号和灵活符号。上、下行符号只能用于上、下行传输，而灵活符号根据信令的指示可以进行上行传输或下行传输。</p>
<h2 id="频域资源的定义"><a href="#频域资源的定义" class="headerlink" title="频域资源的定义"></a>频域资源的定义</h2><p>频域内，无论子载波间隔是多少，都可以将连续的12个子载波定义为一个物理资源块（PRB）。子载波间隔越大，PRB的实际带宽越大。</p>
<h1 id="物理信道和信号"><a href="#物理信道和信号" class="headerlink" title="物理信道和信号"></a>物理信道和信号</h1><h2 id="物理信号"><a href="#物理信号" class="headerlink" title="物理信号"></a>物理信号</h2><p>1.常见的物理信号</p>
<p>NR下行物理信号包括信道状态信息参考信号、解调参考信号、时频跟踪参考信号、相位噪声跟踪参考信号、RRM测量参考信号、RLM测量参考信号等</p>
<p>NR上行物理信号包括探测参考信号、解调参考信号、相位噪声跟踪参考信号等。</p>
<p>其中解调参考信号和行为噪声跟踪参考信号在上下行的设计基本相同。</p>
<p>2.物理信号的设计原则</p>
<ul>
<li>尽量避免持续发送（持续发送：不经系统配置即发送，也无法关闭的信号）的周期性信号。因为持续发送的信号无法关闭，未来系统引入的新业务需要考虑如何避开这些信号，且这些信号会造成不必要的系统开销和功率消耗。</li>
<li>物理信号占用的时频资源应该可以灵活配置。</li>
<li>支持大规模波束赋形传输。（<strong>波束赋形</strong>：调整多天线信号的幅相以产生干涉效应，使最终辐射的信号集中朝着某个方向传播或接收，从数学的角度讲，多天线辐射的射频信号就是很多正弦信号的和，调整每个正弦信号的幅相之后，这些信号和功率在一些会变为零（相消干涉），在另一些位置功率最大（相长干涉））</li>
</ul>
<h2 id="物理信道"><a href="#物理信道" class="headerlink" title="物理信道"></a>物理信道</h2><h3 id="控制信道"><a href="#控制信道" class="headerlink" title="控制信道"></a>控制信道</h3><p>物理信道对应于一组特定的时&#x2F;频资源，用于承载高层映射的传输信号。不承载传输信道的物理信道称为<strong>控制信道</strong>。（传输信道中也有控制信道，但二者明显不是一个概念）</p>
<p>物理下行控制信道用于为UE提供下行接收和上行传输的<strong>必要信息</strong>（如资源分配信息）。</p>
<p>物理上行控制信道承载上行控制信息，用于向基站报告YE的状态。</p>
<h3 id="NR定义的物理信道"><a href="#NR定义的物理信道" class="headerlink" title="NR定义的物理信道"></a>NR定义的物理信道</h3><ul>
<li><strong>物理下行共享信道（PDSCH）</strong>：主要用于下行单播数据的传输，也可以用于寻呼消息和系统消息的传输。天线端口1000~1011</li>
<li><strong>物理广播信道（PBCH）</strong>：承载UE接入网络所需的最小系统信息的一部分。天线端口4000</li>
<li><strong>物理下行控制信道（PDCCH）</strong>：用于传输下行控制信息，主要是UE接收PDSCH和传输上行共享信道（PUSCH）所需的调度信息，也可以传输时隙格式指示和抢占指示。天线端口为2000</li>
<li><strong>物理上行共享信道（PUSCH）</strong>：对应于PDSCH的上行物理信道，用于传输上行业务数据，还可以承载上行控制信息。天线端口1000~1003</li>
<li><strong>物理上行控制信道（PUCCH）</strong>：承载上行控制信息，反馈HARQ-ACK信息，指示下行的传输块是否正确接收；上报信道状态信息；在有上行数据到达时请求上行资源。PUCCH的天线端口为2000。</li>
<li><strong>物理随机接入信道（PRACH）</strong>：用于随机接入过程。天线端口为4000</li>
</ul>
<img src="/2022/04/24/%E7%AC%AC4%E7%AB%A0-%E5%B8%A7%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E4%BF%A1%E9%81%93/%E5%9B%BE2.png" class>



<p>下面将详细介绍下这些物理信道</p>
<h3 id="初始接入信道（下行同步信道（本质是物理广播信道）与物理随机接入信道）"><a href="#初始接入信道（下行同步信道（本质是物理广播信道）与物理随机接入信道）" class="headerlink" title="初始接入信道（下行同步信道（本质是物理广播信道）与物理随机接入信道）"></a>初始接入信道（下行同步信道（本质是物理广播信道）与物理随机接入信道）</h3><p>UE开机或移动到新的小区覆盖范围后，需要通过<strong>下行同步信道</strong>获得与网络的下行同步，如时间和频率的同步、读取小区的广播信息、获取小区的物理表示，从而获取小区的系统信息以确定后续的操作。然而NR所支持的高频率将导致网络覆盖范围变小，通过大规模天线技术将有效地解决高频段带来的覆盖范围变小的难题。而下行同步信道的设计必须考虑覆盖范围的要求，使之与业务信道的范围相匹配。</p>
<p>NR采用<strong>波束扫描</strong>技术提升下行同步信道的覆盖范围，波束扫描即用多个波束在不同方向重复发送下行同步信道，将这些波束合并起来可以覆盖整个小区。</p>
<p>UE开机后获得下行同步，读取完系统广播消息之后，如果UE需要和基站建立无线链路，则UE需要发起<strong>上行随机接入过程</strong>，建立与基站的连接，随后才能进行常规的数据传输和接收。而随机接入过程也需要考虑覆盖范围，也就是说，基站要采用接收波束赋形获得赋性增益，UE也需要采用波束赋性进行发送，才能满足高频段的覆盖要求。</p>
<h3 id="上下行控制信道"><a href="#上下行控制信道" class="headerlink" title="上下行控制信道"></a>上下行控制信道</h3><p>4.1下行控制信道（PDCCH）</p>
<p>上下行业务信道的传输需要相关的下行控制信令辅助，而下行控制信令在PDCCH上传输。下行控制信令的可靠高效传输是上、下行数据传输的前提条件，因此当上、下行数据信道通过大规模天线技术获得了速率和覆盖的提升时，控制信道的覆盖也需要获得与之匹配的提升，否则下行控制信道会成为覆盖的瓶颈。</p>
<p>1.PDCCH多天线方案有以下几种：</p>
<ul>
<li>波束赋性：这里指UE专属的波束赋性，不同UE的PDCCH可以有不同的波束赋性方向。下节将讨论的PDSCH中也会用到波束赋性技术，但二者的目标不一样。PDSCH追求频谱效率，波束应该尽量的窄，以获得更大的波束赋形增益；而对于PDCCH，可靠性是更为重要的目标，因此PDCCH的波束可以宽一些。</li>
<li>发射分级：由于控制信道的可靠性高于数据信道，因此控制信道的设计过程考虑了空间分集方案。</li>
<li>多用户多入多出技术：以提高容量为目标，并没有得到明显的协议支持</li>
<li>空分复用：目的是提高频谱效率，NR不支持PDCCH的空分复用传输。</li>
</ul>
<p>4.2上行控制信道（PUCCH）</p>
<p>NR中关于上行控制信道的一个重要特征是引入了两种PUCCH结构：长PUCCH和短PUCCH。</p>
<p>1.短PUCCH的设计动机：</p>
<ul>
<li>降低HARQ-ACK的时延：为了支持uRLLC业务，希望PDSCH的HARQ-ACK反馈能在尽短时间内完成，这要求PUCCH在较短的时间内完成传输。</li>
<li>支持上行波束赋性传输：其一是因为UE用多个不同的波束重复发送PUCCH，由于模拟波束赋形的特点，UE一个时间点上只能用一个波束进行发送，过长的PUCCH重复传输会占用更多的时域资源，导致系统开销增加。其二是支持基站侧的接受波束扫描，同样由于模拟波束，基站在一个时间点上仅能用一个模拟波束接收PUCCH，短PUCCH可以实现不同UE的PUCCH&#x2F;PUSCH的时分复用。</li>
</ul>
<img src="/2022/04/24/%E7%AC%AC4%E7%AB%A0-%E5%B8%A7%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E4%BF%A1%E9%81%93/%E5%9B%BE3.png" class title="PUCCH&#x2F;PUSCH的时分复用">



<h3 id="上、下行业务信道"><a href="#上、下行业务信道" class="headerlink" title="上、下行业务信道"></a>上、下行业务信道</h3><p>下行共享信道（DL-SCH）是下行数据的主要传输信道，映射到PDSCH上进行传输。同理，上行共享信道（UL-SCH）是上行数据的主要传输信道，映射到PUSCH上进行传输。</p>
<p>PDSCH和PUSCH频域资源调度类似于LTE，但增加了BWP的指示。</p>
<p>NR时域资源调度比LTE更加灵活,PDSCH和PUSCH的时域资源的映射类型有两种：TypeA和TypeB。TypeA是基于时隙的调度；TypeB是基于微时隙的调度，主要目标是支持uRLLC业务，使起始符号位置可以使任意的符号。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/" class="post-title-link" itemprop="url">第3章-无线接口协议栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-23 11:03:49" itemprop="dateCreated datePublished" datetime="2022-04-23T11:03:49+08:00">2022-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-26 15:27:10" itemprop="dateModified" datetime="2022-04-26T15:27:10+08:00">2022-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>1.在5G系统中，将终端和接入网之间的接口简称为<strong>Uu接口</strong>，也成为<strong>空中接口</strong>。</p>
<p>2.<strong>无线接口协议</strong>：建立、重配置和释放各种无线承载业务。主要分为三层两面，三层指的是<strong>物理层、数据链路层、网络层</strong>；两面指的是<strong>控制平面</strong>和<strong>用户平面</strong>。</p>
<ul>
<li><p>物理层是指MAC层，位于控制平面和用户平面。</p>
</li>
<li><p>数据链路层可分成媒体访问控制（MAC）层、无线链路控制（RLC）层、分组数据汇聚协议（PDCP）层、服务数据自适应协议（SDPA）四个子层，相比于LTE多了SDPA层，且SDPA层只位于用户平面，其余三个子层同时位于控制平面和用户平面。</p>
</li>
<li><p>网络层指无线资源控制（RRC）层，位于控制平面。</p>
</li>
</ul>
<p>3.无线接口协议栈</p>
<ul>
<li>控制平面协议栈：负责对无线接口的管理和控制</li>
</ul>
<img src="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9B%BE1.png" class title="控制平面协议栈">

<ul>
<li>用户平面协议栈</li>
</ul>
<img src="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9B%BE2.png" class title="用户平面协议栈">

<h2 id="物理层协议功能"><a href="#物理层协议功能" class="headerlink" title="物理层协议功能"></a>物理层协议功能</h2><p>物理层为MAC和更好层提供信息传输服务，其中所提供的服务通过传输信道来描述。</p>
<p>1.下行传输信道类型</p>
<ul>
<li>广播信道BCH：采用固定的预定义传输格式，能偶在整个小区覆盖区域内广播。</li>
<li>下行共享信道DL_SCH：使用混合自动重传请求（HARQ）传输，能够通过调整传输使用的调制方式、编码速率和发送功率来实现链路自适应，在整个小区内发送或使用波束赋形发送，支持动态或半静态的资源分配，支持终端非连续接收，达到节电的目的。</li>
<li>寻呼信道PCH：支持终端非连续接收，能在整个小区覆盖范围传输，使用映射到可用于动态使用的业务或者其他的控制信道的物理资源上。</li>
</ul>
<p>2.上行传输信道类型</p>
<ul>
<li>上行共享信道UL_SCH：与下行共享信道DL_SCH一样</li>
<li>随机接入信道RACH：承载有限的控制信息，并且具有冲突碰撞特征。</li>
</ul>
<img src="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9B%BE3.png" class title="映射关系">

<h2 id="数据链路层协议功能"><a href="#数据链路层协议功能" class="headerlink" title="数据链路层协议功能"></a>数据链路层协议功能</h2><img src="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9B%BE4.png" class title="数据链路层的下行架构">
<img src="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9B%BE5.png" class title="数据链路层的上行架构">

<p>物理层为MAC子层提供传输信道级的服务，MAC子层为RLC子层提供逻辑信道级的服务，RLC子层为PDCP子层提供RLC信道级服务，PDCP子层为SDAP子层提供无线承载级的服务，SDAP子层为上层提供SGC Qos流级的服务。</p>
<h3 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h3><p>Ⅰ、MAC子层的功能</p>
<p>①逻辑信道到传输信道的映射</p>
<p>②来自多个逻辑信道的MAC业务数据单元的复用和解复用</p>
<p>③上行调度信息上报</p>
<p>④通过HARQ进行错误纠正</p>
<p>⑤通过动态调度实现UE间的优先级处理</p>
<p>⑥通过逻辑信道优先级来实现终端内多个逻辑信道的优先级处理</p>
<p>⑦当实际传输数据量不能填满整个授权的数据库大小时使用填充功能</p>
<p>Ⅱ、逻辑信道</p>
<p>MAC层根据传输的信息类型划分为多种逻辑信道类型，针对不同的数据类型，提供不同的传输服务。一般将逻辑信道分为<strong>控制信道</strong>（传输控制平面信息）和<strong>业务信道</strong>（传输用户平面信息）</p>
<p>控制信道分为</p>
<ul>
<li>广播控制信道BCCH：为系统广播信息传输使用的下行信道。</li>
<li>寻呼控制信道PCCH：为传输寻呼信息、系统信息改变通知消息以及指示是否有正在广播的公共告警系统信息的下行信道。</li>
<li>公共控制信道CCCH：用于当终端和网络之间没有无线资源控制层（RRC）时，传输终端和网络之间的控制信息，双向。</li>
<li>专用控制信道DCCH：为点对点的双向信道，用于终端侧和网络侧存在RRC时的专用控制信息传输，双向。</li>
</ul>
<p>业务信道仅有专用业务信道DTCH，用于针对单个用户的点到点的业务传输信道，可单向可双向。</p>
<p>Ⅲ、逻辑信道与传输信道的映射关系</p>
<img src="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9B%BE6.png" class title="上行逻辑信道到上行传输信道的映射关系">
<img src="/2022/04/23/%E7%AC%AC3%E7%AB%A0-%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E6%A0%88/%E5%9B%BE7.png" class title="下行逻辑信道到下行传输信道的映射关系">

<h3 id="RLC子层"><a href="#RLC子层" class="headerlink" title="RLC子层"></a>RLC子层</h3><p>为了满足不同的业务需求，RLC子层支持三种传输模式：<strong>透明模式</strong>（TM）、<strong>非确认模式</strong>（UM）、<strong>确认模式</strong>（AM）。RLC的配置基于逻辑信道的颗粒度，不依赖于底层的参数集和传输时间间隔的长度。</p>
<p>透明模式主要用于寻呼消息、系统信息广播以及SRB0信令的传输</p>
<p>其他SRB信令用确认模式传输</p>
<p>用于传输用户数据的DRB可以根据业务类型选择确认模式或非确认模式。</p>
<p><strong>补充</strong>：RB&#x3D;Resource Bearer（终端与基站之间的承载） SRB&#x3D;Signal RB（终端与基站之间的信令承载） DRB &#x3D; Data RB（终端与基站之间的数据承载）</p>
<p>其中<strong>SRB0</strong>用于使用CCCH逻辑信道的RRC消息，<strong>SRB1</strong>用于RRC消息（可能包括后向装载的NAS消息）以及SRB2建立之前的NAS消息，均使用DCCH逻辑信道。<strong>SRB2</strong>用于NAS消息，全部使用DCCH逻辑信道。<strong>SRB3</strong>用于UE在EN-DC中时的特定RRC消息，均使用DCCH逻辑信道。</p>
<h3 id="PDCP子层"><a href="#PDCP子层" class="headerlink" title="PDCP子层"></a>PDCP子层</h3><p>PDCP子层为控制平面和用户平面提供不同的服务。</p>
<p>PDCP子层用于用户平面的功能包括</p>
<ul>
<li>支持头压缩解压缩功能，包含健壮性报头压缩协议算法。</li>
<li>提供序列号使得其可以支持确认模式下逻辑信道向高层进行重排序、按需递交，及对底层SDU数据的重复检测。</li>
<li>切换过程中，支持对确认模式逻辑信道的PDCP SDU重传</li>
<li>加密、解密和完整性保护</li>
<li>业务平面数据的传输</li>
<li>上行基于定时器的SDU丢弃机制</li>
<li>支持PDCP分离承载的路由功能</li>
<li>复制PDCP PDU，将其分发到不同路径上。</li>
</ul>
<p>PDCP子层用于控制平面的功能包括：</p>
<ul>
<li>加密、解密和完整性保护；</li>
<li>控制平面数据的传输；</li>
<li>提供序列号使得其可以支持确认模式下逻辑信道向高层进行重排序、按需递交，及对底层SDU数据的重复检测。</li>
<li>复制PDCP PDU，将其分发到不同路径上。</li>
</ul>
<p><strong>补充</strong>：SDU为服务数据单元，PDU为协议数据单元，本层的PDU是下层的SDU，本次的SDU是上层的PDU。</p>
<h3 id="SDAP子层"><a href="#SDAP子层" class="headerlink" title="SDAP子层"></a>SDAP子层</h3><p>SDAP子层主要功能是完成QoS流和DRB之间的映射，对上行和下行数据分组增加QoS流的标识号，并将不同的QoS流映射到数据无线承载上，每个独立的PDU会话会配置一个SDAP实体。</p>
<h2 id="RRC层协议功能"><a href="#RRC层协议功能" class="headerlink" title="RRC层协议功能"></a>RRC层协议功能</h2><p>RRC层协议模块是接入层的控制中心，其功能包括：发送系统信息广播（非接入层和接入层）相关信息、发送由核心网5GC和接入网NG-RAN发起的寻呼消息，UE和NG-RAN之间的RRC建立、维护和释放，安全功能密钥管理，无线承载管理（包括建立、配置、维护和释放信令无线承载和用户无线承载），移动性管理（包括切换、UE小区选择和重选、切换时上下文传输），QoS管理，UE测量报告和控制，无线链路失败的检测和恢复，以及NAS消息的传输。</p>
<p>RRC协议状态由LTE的3个增加为3个：RRC_IDEL、RRC_INACATIVE、RRC_CONNECTED</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/04/%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/" class="post-title-link" itemprop="url">第6章_接口、lambda表达式与内部类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-04 20:33:36" itemprop="dateCreated datePublished" datetime="2022-04-04T20:33:36+08:00">2022-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-05 14:11:29" itemprop="dateModified" datetime="2022-04-05T14:11:29+08:00">2022-04-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>1.接口中不能含有实例域，但是可以含有常量（接口中的域自动声明为public static final），可以含有方法，在Java SE 8之后，可以在接口中实现方法。此外，接口中的所有方法自动地属于public。但是，在实现接口的类中应该将方法显示声明为public。在Java SE 8中，允许在接口中增加静态方法。</p>
<p>2.接口与抽象类：每个类只能扩展一个类，而接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<p>3.默认方法：可以在接口中为接口方法提供一个默认实现，但必须用default标记该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样当某个类实现这个接口时，可以无需实现这个默认方法，并且该类调用该方法时，也会转成调用接口的这个方法，不会报错。</p>
<p>4.解决默认方法冲突：</p>
<p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，Java解决这种二义性的规则如下：</p>
<ol>
<li>超类优先：如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li>
<li>接口冲突：如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li>
</ol>
<h1 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/03/%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/03/%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">第5章_继承</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-03 15:12:54" itemprop="dateCreated datePublished" datetime="2022-04-03T15:12:54+08:00">2022-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-04 20:18:35" itemprop="dateModified" datetime="2022-04-04T20:18:35+08:00">2022-04-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h1><p>1.子类无法直接访问超类的私有域，虽然子类对象也拥有与超类同名的域。不过可以通过super.域访问器来访问超类的私有域。</p>
<p>2.子类构造器：由于子类无法直接访问超类的私有域，所以子类的初始化必须利用超类的构造器对私有域进行初始化。使用super调用构造器的语句必须是子类构造器的第一句，如果子类构造器没有显式调用超类构造器，将自动调用超类无参构造器。如果子类没有显式调用超类构造器并且超类也没有无参构造器，则Java编译器会报错。</p>
<p>3.关键字this有两个用途：一是引用隐式参数，二是调用该类的其他的构造器。</p>
<p>而关键字super有两个用途：一是调用超类的方法，二是调用超类的构造器。</p>
<p>4.多态：一个对象变量可以指示多种实际类型的现象被称为多态。</p>
<p>一个Employee变量既可以引用一个Employee类对象，也可以引用Employee类的任何一个子类的对象。然而，不能将一个超类的引用赋值给子类变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Manager</span>(...);<span class="comment">//Manager extends Employee</span></span><br></pre></td></tr></table></figure>

<p>在Java中，子类数组的引用可以转换为超类数组的引用，而不需要强制转换。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager[] managers = <span class="keyword">new</span> <span class="title class_">Manager</span>[<span class="number">10</span>];</span><br><span class="line">Employee[] staff = manager;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<p>此时manager和staff引用的是同一个数组，虽然上述代码没有问题，但当往staff中存入一个Employee对象时，manager[0]和staff[0]引用的是同一个Employee对象，似乎我们把一个Employee对象引用赋值给一个Manager。为了不犯这种错误时，所有数组都要牢记创建它们的元素类型，并且负责监督仅将类型兼容的引用存储到数组中。</p>
<p>5.在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p>
<p>6.动态绑定：运行时能够自动地选择调用哪个方法的现象称为动态绑定。</p>
<p>7.阻止继承：final类和方法。</p>
<p>如果一个类被声明为final，则这个类不能被继承。类中的方法也被声明为final，而域并不会被声明为final。</p>
<p>如果一个方法被声明为final，则这个方法不能被重写。</p>
<p>如果一个域被声明为final，则这个方法不能被再次赋值。</p>
<p>8.强制类型转换（尽量少使用）</p>
<ul>
<li>只能在继承层次内进行类型转换。</li>
<li>在将超类转换成子类之前，应该使用instanceof进行检查。</li>
</ul>
<p>9.抽象类</p>
<p>抽象方法充当着占位的角色，它们的具体实现在子类中。包含一个或多个抽象的方法的类需要声明为抽象类，反之，抽象类可以不拥有抽象方法。扩展抽象类可以有两种选择。一种是在抽象类定义部分抽象类方法或不定义抽象方法，这样子类就必须标记为抽象类。另一种是定义全部的抽象方法，这样子类就无需定义为抽象类。</p>
<p>10.Java的4个访问修饰符</p>
<ol>
<li>仅对本类可见—-private。</li>
<li>对所有类可见—-public。</li>
<li>对本包和所有子类可见—-protected。</li>
<li>对本包可见—-默认，不需要修饰符。</li>
</ol>
<h1 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h1><p>1.equals方法：在Object类中，这个方法将判断两个对象是否具有相同的引用。然而对于许多类来说这种方法没有意义，因此会重写equals类用来比较内容。例如：如果两个雇员对象的姓名、薪水和雇佣日期都一样，就认为它们是相等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == otherObject)<span class="comment">//判断是否为同一对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (otherObject == <span class="literal">null</span>)<span class="comment">//判断是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass())<span class="comment">//判断类型是否相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//至此，otherObject可证得是引用的非空的Employee对象</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;<span class="comment">//强制转换</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, other.name)</span><br><span class="line">                &amp;&amp; salary == other.salary</span><br><span class="line">                &amp;&amp; Objects.equals(hireDay, other.hireDay);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面给出编写一个完美的equals方法的建议：</p>
<ol>
<li><p>显示参数命名为otherObject，稍后需要将它转换为另一个叫做other的变量。</p>
</li>
<li><p>检测this与otherObject是否引用同一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测otherObject是否为null，如是则返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变（如Employee比较姓名、薪水、雇佣日期，而Manager比较姓名、薪水、雇佣日期和奖金，因此二者equals语义不同），就是用getClass检测。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>如果所有子类都拥有统一的子类，就是用instanceof检测</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将otherObject转换为相应的类类型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对所有需要的域进行比较。使用&#x3D;&#x3D;比较基本类型域，使用equals比较对象域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">return</span> <span class="variable">field1</span> <span class="operator">=</span>= other.field1</span><br><span class="line">                &amp;&amp; Objects.equals(field2, field2);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.hashCode方法：重写equals方法就必须重写hashCode方法。因为hashCode和equals两个方法是用来协同判断两个对象是否相等，采用这种方式的原因是可以提高程序插入和查询的速度。如果重写equals时，不重写hashCode，就会导致在某些场景下，如将两个相等的自定义对象存储在Set集合时，Set进行去重操作，会先判断两个对象hashCode是否相同，返回false，就不再执行equals方法，直接返回false。则在Set中保留了两个一摸一样的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Equals和hashCode的定义必须一致，如果x.equals(y)返回true，那么x.hashCode和y.hashCode返回值就必须一致。如：equals比较雇员的ID，那么hashCode方法就需要散列ID。</p>
<p>3.toString方法：强烈建议为自定义的每一个类增加toString方法。</p>
<h1 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h1><p>1.基本数据类型的包装器类：Integer、Long、Float、Double、Short、Byte、Character和Boolean，前六个类全派生于超类Number。</p>
<p>自动装箱：将基本数据类型自动转换为对应的包装器类。</p>
<p>自动拆箱：将包装器类自动转换为对应的基本数据类型。</p>
<p>对象包装器类是不可变的，一旦构造了包装器，就不可更改包装在其中的值。此外，对象包装器类是final，因此不能定义它们的子类。</p>
<h1 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> format(fmt, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数为Object[]数组，如果调用者提供的是整型数组和其他基本类型的值，则会自动装箱。</p>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>1.在比较两个枚举类型的值时，永远不要调用equals，而直接使用“&#x3D;&#x3D;”就可以了。</p>
<p>2.枚举类中可以添加域、方法、构造器，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String abbreciation;</span><br><span class="line"></span><br><span class="line">    Size(String abbreciation) &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbreciation = abbreciation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreciation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbreciation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h1><ol>
<li>将公共操作和域放在超类。</li>
<li>不要使用受保护的域。</li>
<li>使用继承实现“is-a”关系。</li>
<li>除非所有继承的方法都有意义，否则不要使用继承。</li>
<li>在覆盖方法时，不要改变预期的行为。</li>
<li>使用多态，而非类型信息。</li>
<li>不要过多的使用反射。</li>
</ol>
<p>本章就到这了~</p>
<img src="/2022/04/03/%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF/%E9%B8%A3%E4%BA%BA.webp" class title="鸣人">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/01/%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/01/%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/" class="post-title-link" itemprop="url">第4章_对象与类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-01 20:46:58" itemprop="dateCreated datePublished" datetime="2022-04-01T20:46:58+08:00">2022-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-03 10:46:56" itemprop="dateModified" datetime="2022-04-03T10:46:56+08:00">2022-04-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h1><p>1.类是构造对象的模板和蓝图。</p>
<p>封装：封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域，而仅通过对象的方法与对象数据进行交互。这样对对象的使用者就隐藏了数据的实现方法。OOP的另一原则为继承。</p>
<p>2.对象的三个主要特征</p>
<ul>
<li>对象的行为：可以对对象施加哪些方法？</li>
<li>对象的状态：当实践那些方法时，对象如何响应？</li>
<li>对象标识：如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<p>3.类之间的关系</p>
<ul>
<li>依赖（”uses-a“）：如果一个类A的方法操纵另一个类B的对象，则说类A依赖于类B。代码应尽量将相互依赖的类减至最少，以减小产生代码的概率，即让类之间的耦合度最小。</li>
<li>聚合（”has-a“）：即类A的对象包含B的对象。</li>
<li>继承（”is-a“）：表示特殊与一般的关系，下一章会详细讨论。</li>
</ul>
<h1 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h1><p>1.Date类与LocalDate类</p>
<p>标准Java类库包含了两个类：一个是用来表示时间点的Date类；另一个是用来表示日历的LocalDate类。</p>
<p>以上两种类的构造对象方法不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">deadline</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//Date类使用构造器来构造方法</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();<span class="comment">//LocalDate使用静态工厂方法</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">newYearsEve</span> <span class="operator">=</span> LocalDate.of(<span class="number">1999</span>,<span class="number">12</span>,<span class="number">31</span>);</span><br></pre></td></tr></table></figure>

<p>一个用来显示本月日历的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> date.getMonthValue();<span class="comment">//目前的月份</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> date.getDayOfMonth();<span class="comment">//目前的日期</span></span><br><span class="line"></span><br><span class="line">        date = date.minusDays(today - <span class="number">1</span>);<span class="comment">//将date转为本月的第一天</span></span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> date.getDayOfWeek();<span class="comment">//本月第一天的星期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue();<span class="comment">//1-&gt;星期一 2-&gt;星期二  以此类推</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; value; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (date.getMonthValue() == month) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>, date.getDayOfMonth());</span><br><span class="line">            <span class="keyword">if</span> (date.getDayOfMonth() == today) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            date = date.plusDays(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (date.getDayOfWeek().getValue() == <span class="number">1</span>)</span><br><span class="line">                System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (date.getDayOfWeek().getValue() != <span class="number">1</span>)</span><br><span class="line">            System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h1><p>1.隐式参数与显示参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(<span class="type">double</span> byPercent)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary += raise;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出现在方法面前的类对象称为隐式参数，在每一个方法中，用关键字this表示隐式参数。而位于方法名后括号中的数值称为显示参数，如double byPercent。</p>
<p>2.final实例域</p>
<p>当将实例域定义为final，构建对象时必须初始化这样的域，并且在后面的操作中，不能够再对他进行修改。因此，final修饰符大多应用于基本类型域或不可变类的域。</p>
<h1 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h1><p>1.静态域：如果将域定义为static，则该类的所有对象共享这个域，这个域属于这个类而非某个对象。</p>
<p>2.静态常量：静态变量使用较少，而静态常量却使用较多。静态常量可以直接通过类来访问，而无需通过类的对象再来访问，如Math类中定义了一个静态常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure>

<p>在程序中即可通过Math.PI的形式得到这个值。</p>
<p>这行代码中PI虽然为公有域，可以被每个类对象进行修改，但是又由于其被final修饰，不允许再次赋值，所以不会面临被修改的风险。</p>
<p>3.静态方法：静态方法是一种不能向对象实时操作的方法，即没有隐式参数。静态方法无法访问类中非静态方法与非静态域，但是可以访问自身类中的静态域。</p>
<p>以下两种情况使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，所需参数都是显示参数，如Math.pow。</li>
<li>一个方法只需要访问类中的静态域。</li>
</ul>
<h1 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h1><p>1.计算机科学中有两种调用方式：</p>
<ul>
<li>按值调用：方法接收的是调用者提供的值。</li>
<li>按引用调用：方法接收的是调用者提供的变量地址。</li>
</ul>
<p><strong>Java总是采用按值调用。</strong>而Java方法参数的使用情况可以分为以下三种：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tripleValue</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">        x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使通过上述方法将变量value赋值给参数x，也无法修改value的值。因为value只将它的值赋给了x，参数变量x在方法结束就不再使用，无法对value造成影响。</p>
<ul>
<li>一个方法可以改变一个对象参数的状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tripleSalary</span><span class="params">(Employee x)</span> &#123;</span><br><span class="line">        x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法可以成功修改Employee对象的状态（即Salary提高两倍），因为参数变量被赋予的是一个对象引用。</p>
<ul>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Employee x, Employee y)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上方法无法成功让两个对象参数互换。假设我们通过以下代码调用上面这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Carl Cracker&quot;</span>, <span class="number">75000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry Hacker&quot;</span>, <span class="number">50000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">swap(a, b);</span><br></pre></td></tr></table></figure>

<p>首先，我们需要明白a，b的值分别对应的都是一个Employee对象的引用。因此，当调用swap方法时参数变量x，y的值也是Employee对象的引用。经过swap方法后，参数变量x，y值对换，即双方引用的对象交换了。但是a，b的值并没有变化。</p>
<h1 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h1><p>2.无参数的构造器</p>
<p>当类没有提供任何构造器时，系统会提供一个默认的无参构造器。但是当类给出了一个构造器，此时系统不会默认提供无参构造器，如果需要则需要显式声明。</p>
<p>3.调用另一个构造器</p>
<p>构造器的第一个语句可以为形如this(…)的形式，这样这个构造器可以调用本类的其他构造器，从而避免重复编写代码。</p>
<p>4.初始化块：初始化块是除了在构造器中赋值、在声明中赋值外的第三种初始化数据域方式。初始化数据域有多种方式，以下为调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值（0、false、null）</li>
<li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器的第一行调用了第二个构造器，则执行第二个构造器的主体。</li>
<li>执行第一个构造器的主体。</li>
</ol>
<h1 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h1><ol>
<li><p>一定要保证数据私有：绝对不要破坏封装性。</p>
</li>
<li><p>一定要对数据初始化：不要依赖于系统的默认值，而是应该显式地初始化所有的数据，具体的初始化方式可以是提供默认值，也可以在所有构造器中设置默认值。</p>
</li>
<li><p>不要在类中使用过多的基本类型：用其他的类代替多个相关的基本类型的使用。例如：用一个称为Address的新类替换一个Customer类中以下的实例域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String street;</span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> zip;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不是所有的域都需要独立的域访问器和域更改器。</p>
</li>
<li><p>将职责过多的类进行分解。</p>
</li>
<li><p>类名和方法名要能够体现它们的职责。</p>
</li>
<li><p>优先使用不可变的类：这样可以在多个线程间共享其对象。当然，并不是所有的类都应当是不可变的。如果员工加薪时让raiseSalary方法返回一个新的Employee对象，这回很奇怪。</p>
</li>
</ol>
<p>好了，本章就到这了~~</p>
<img src="/2022/04/01/%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/1.webp" class title="这是一直杰尼龟">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Hexo搭建博客图片无法显示问题解决方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-01 19:32:49 / 修改时间：20:24:28" itemprop="dateCreated datePublished" datetime="2022-04-01T19:32:49+08:00">2022-04-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>基于Hexo搭建的博客平台在上传图片时会遇到图片无法打开的情况，解决方法如下：</p>
<p>1.在博客的根目录下的配置文件_config.yml中的post_asset_folder: false改为true（注意:后有一空格），这样在新建博客时就会自动建立一个同名的文件夹，这样我们可以将博客中用到的图片放在上述文件夹中。</p>
<img src="/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E6%AD%A5%E9%AA%A41.png" class title="步骤1">

<p>2.git bash安装插件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>如果git bash安装插件失败，可以试试以管理员方式运行cmd，然后转到博客所在的文件夹，在执行上述命令。</p>
<p>3.在编写博客时，需要用到图片的地方使用以下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 杰尼龟.webp 这是一直杰尼龟 %&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的 杰尼龟.webp 改成第一步中自动建立的文件夹中所需图片的名字 + .图片格式（jpg，png等），将上面的 这是一只杰尼龟 改成你图片的描述。</p>
<p>这样问题就解决了，效果如下：</p>
<img src="/2022/04/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E6%9D%B0%E5%B0%BC%E9%BE%9F.webp" class title="这是一直杰尼龟">


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/30/%E7%AC%AC3%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/30/%E7%AC%AC3%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">第3章_Java的基本程序设计结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-30 20:45:16" itemprop="dateCreated datePublished" datetime="2022-03-30T20:45:16+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-01 19:29:13" itemprop="dateModified" datetime="2022-04-01T19:29:13+08:00">2022-04-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一个简单的Java应用程序"><a href="#一个简单的Java应用程序" class="headerlink" title="一个简单的Java应用程序"></a>一个简单的Java应用程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;We will not use &#x27;Hello World!&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>public称为<strong>访问修饰符</strong>，用于控制程序的其他部分对于该代码的访问级别，访问修饰符将在第5章详细介绍。</p>
<p>class为关键字，可将class（类）看作一个加载程序逻辑的容器。</p>
<p>class后紧跟类名FirstSample，Java定义类名的规则为：名字必须以字母开头，后面可跟字母和数字的任意组合，长度基本没有限制，但是不能使用Java的保留字（如public、class等）作为类名。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Java中，有3种标记注释的方法，分别为：</p>
<p>1.使用&#x2F;&#x2F;，注释内容从&#x2F;&#x2F;开始到本行结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;We will not use &#x27;Hello World!&#x27;&quot;</span>);<span class="comment">//is this too cute?</span></span><br></pre></td></tr></table></figure>

<p>2.使用&#x2F;* 和*&#x2F;将长篇的注释括起来，注意，在Java中&#x2F;**&#x2F;不能嵌套。</p>
<p>3.以&#x2F;**开始，以 *&#x2F;结束，可以用来自动生成文档。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 水中岚</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java是一种强类型语言，意味着必须为每一个变量声明一种类型。在Java中一共有8种基本类型，包含4种整形，2种浮点类型，一种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真假的boolean类型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储要求</th>
<th align="center">类型</th>
<th align="center">储存要求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">float</td>
<td align="center">4字节</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">double</td>
<td align="center">8字节</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">char</td>
<td align="center">2字节</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">1字节</td>
<td align="center">boolean</td>
<td align="center">1字节</td>
</tr>
</tbody></table>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>1.常量：在Java中，利用关键字final指示常量，其表示这个变量只能被赋值一次，习惯上，常量名使用全大写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">CM_PER_INCH</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br></pre></td></tr></table></figure>

<p>2.数值类型之间的转换</p>
<img src="/2022/03/30/%E7%AC%AC3%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" class title="数字类型之间的转换">

<p>上图给出了Java中的合法转换，其中实线表示转换时无精度损失，虚线表示转换时有精度损失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123456789</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> n;<span class="comment">//f is 1.23456792E8</span></span><br></pre></td></tr></table></figure>

<p>如果需要非合法转换时，如需要将double转为int，则需要用到强制类型转换。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>1.equals用来比较字符串是否相等，&#x3D;&#x3D;用来比较两个字符串位置是否相同。虽然位置相同的字符串值必定相等，但相等的字符串并不一定会在同一位置。</p>
<p>2.文件输入与输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.get(<span class="string">&quot;myfile.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//读取文件</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//写入数据至文件</span></span><br></pre></td></tr></table></figure>

<p>注意，读取文件不能使用下面的形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>否则，scanner变量 in 会将参数作为包含了’m’、’y’、’f’、’i’等十个字符的数据，而非参数字符串对应的文件中的数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/25/hexo%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/me.jpg">
      <meta itemprop="name" content="水中岚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水中岚">
      <meta itemprop="description" content="水中岚的博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 水中岚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/25/hexo%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Hexo编写博客</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-25 10:35:47 / 修改时间：15:39:52" itemprop="dateCreated datePublished" datetime="2022-03-25T10:35:47+08:00">2022-03-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文将针对”Hexo编写博客“进行记录</p>
<h1 id="Hexo写作"><a href="#Hexo写作" class="headerlink" title="Hexo写作"></a><strong>Hexo写作</strong></h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>创建文章、页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;文章名&gt;</span><br></pre></td></tr></table></figure>

<p>在你的博客文件下打开Git Bash，输入上方命令，[layout]表示布局，为可选参数。&lt;文章名&gt;为你想要创建的文章名字，输入时删去&lt;&gt;符号，保留文章名即可。</p>
<p>Hexo有三种默认的布局，分别为post、page、draft，不同的文件将会被保存在不同的路径。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>文件保存路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source&#x2F;_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source&#x2F;_drafts</td>
</tr>
</tbody></table>
<p>Hexo默认以文章名为文件名称，当然，我们也可以修改_config.yml配置文件中的new_post_name参数来修改默认文件名称。如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>

<p>则可以在文件名中添加上日期，方便管理。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:title</td>
<td>标题（空格将会替换为短杆）</td>
</tr>
<tr>
<td>:year</td>
<td>建立文件的年份</td>
</tr>
<tr>
<td>:month</td>
<td>建立文件的月份，如04</td>
</tr>
<tr>
<td>:i_month</td>
<td>建立文件的月份，如4</td>
</tr>
<tr>
<td>:day</td>
<td>建立文件的日期，如03</td>
</tr>
<tr>
<td>:i_day</td>
<td>建立文件的日期，如3</td>
</tr>
</tbody></table>
<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter指的是文件上方以 — 分割的区域，用于设置文件的参数。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo编写博客</span><br><span class="line">date: 2022-03-25 10:35:47</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>下表为一些可以设置的参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td>post</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>文章的文件名</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文章的建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
<td></td>
</tr>
</tbody></table>
<h2 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h2><p>Hexo官网（<a href="Hexo%E5%AE%98%E7%BD%91"> https://hexo.io/zh-cn/docs/tag-plugins</a>）中提供一些文章中快速插入如引用块、代码等特定内容的插件。这里，我推荐直接使用Typora来完成文章的编写。</p>
<p>Typora是一款Markdown编辑器，当我们输入完标记语言后就可以直接看见效果，并且许多标记语言可以直接通过快捷键或者软件上方工具栏来设置。</p>
<h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>最后，在编写完文章后，不要忘记重新部署</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">水中岚</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
